#version 450

// 定义工作组大小。这个值可以调整。
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// 输入缓冲区 (张量)
// 绑定 0: 'vecs' - 向量查找表
layout (set = 0, binding = 0) readonly buffer VecsBuffer {
    float vecs_data[];
};
// 绑定 1: 'ids' - 'vecs' 的索引
layout (set = 0, binding = 1) readonly buffer IdsBuffer {
    uint ids_data[]; // 假设索引是非负的
};
// 绑定 2: 'src' - 源向量
layout (set = 0, binding = 2) readonly buffer SrcBuffer {
    float src_data[];
};

// 输出缓冲区 (张量)
// 绑定 3: 'residuals' - 输出的残差
layout (set = 0, binding = 3) writeonly buffer ResidualsBuffer {
    float residuals_data[];
};

// 推送常量：从 C++ 传递的参数
layout (push_constant) uniform PushConstants {
    uint dim;             // 每个向量的维度
    uint num_residuals;   // 要计算的残差总数 (实际上是 ids.size())
};

void main() {
    // 获取全局调用 ID，它对应于我们正在计算的残差向量的索引
    uint residual_idx = gl_GlobalInvocationID.x;

    // 边界检查：仅在 num_residuals 范围内处理
    if (residual_idx >= num_residuals) {
        return;
    }

    // 从 'ids_data' 缓冲区获取 'vecs' 张量的 ID (行索引)
    uint selected_vec_id = ids_data[residual_idx];

    // 计算访问扁平张量数组中元素的基准偏移量
    uint src_base_offset = residual_idx * dim;
    uint residual_base_offset = residual_idx * dim;
    // selected_vec_id 是 'vecs_data' 的行索引
    uint vecs_base_offset = selected_vec_id * dim;

    // 对向量的每个分量执行残差计算
    for (uint j = 0; j < dim; ++j) {
        float src_val = src_data[src_base_offset + j];
        // 重要：确保 selected_vec_id 是 vecs_data 的有效索引，
        // 并且 (vecs_base_offset + j) 在边界内。
        // 这个责任在于调用者提供的数据。
        float vec_val = vecs_data[vecs_base_offset + j];
        
        residuals_data[residual_base_offset + j] = src_val - vec_val;
    }
}